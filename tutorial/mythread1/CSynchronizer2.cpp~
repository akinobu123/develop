#include <stddef.h>
#include <errno.h>
#include <sys/time.h>
#include <assert.h>

#include "CSynchronizer2.h"

// constructors & destructor
CSynchronizer2::CSynchronizer2()
{
    if (pthread_mutex_init(&fLock, NULL) != 0) {
        assert(false);
    }

    if (pthread_cond_init(&fReleased, NULL) != 0) {
        assert(false);
    }

    if (pthread_cond_init(&fNotified, NULL) != 0) {
        assert(false);
    }
}

CSynchronizer2::~CSynchronizer2()
{
    if (pthread_mutex_destroy(&fLock) != 0) {
        assert(false);
    }

    if (pthread_cond_destroy(&fReleased) != 0) {
        assert(false);
    }

    if (pthread_cond_destroy(&fNotified) != 0) {
        assert(false);
    }
}

// public member functions
CSynchronizer2* CSynchronizer2::createInstance()
{
    return new CSynchronizer2();
}

// Gets a lock
void CSynchronizer2::lock()
{
    if (pthread_mutex_lock(&fLock) != 0) {
        assert(false);
        return;
    }

    if (getState() != eLocked) {
        setState(eLocked);
        setThreadID(pthread_self());
    } else if (!pthread_equal(getThreadID(), pthread_self())) {
        while (getState() == eLocked) {
            pthread_cond_wait(&fReleased, &fLock);
        }

        setState(eLocked);
        setThreadID(pthread_self());
    } else {
        // Recursive call.  Just increment the locked level.
    }


    incrementLockedLevel();

    if (pthread_mutex_unlock(&fLock) != 0) {
        assert(false);
        return ;
    }
}

// Releases a lock
void CSynchronizer2::unlock()
{
    bool released = false;

    if (pthread_mutex_lock(&fLock) != 0) {
        assert(false);
        return;
    }

    if (! isLockedBySelf()) {
        pthread_mutex_unlock(&fLock);
        assert(false);
        return;
    }

    decrementLockedLevel();

    if (getLockedLevel() == 0) {
        setState(eUnlocked);
        released = true;
    }

    if (released) {
        if (pthread_cond_signal(&fReleased) != 0) {
            assert(false);
            return;
        }
    }

    if (pthread_mutex_unlock(&fLock) != 0) {
        assert(false);
        return;
    }
}

// Release a lock, then waits until either some other thread invokes the notify
// method or the notifyAll method
void CSynchronizer2::wait()
{
    wait(0);
}

bool CSynchronizer2::wait(
    int msec)
{
    assert(msec >= 0);

    if (pthread_mutex_lock(&fLock) != 0) {
        assert(false);
        return false;
    }

    if (! isLockedBySelf()) {
        pthread_mutex_unlock(&fLock);
        assert(false);
        return false;
    }

    saveThreadLockedInfo();

    bool result = true;
    if (msec <= 0) {
        if (pthread_cond_wait(&fNotified, &fLock) != 0) {
            assert(false);
            return false;
        }
    } else {
        struct timeval now;
        gettimeofday(&now, 0);

        struct timespec timeout;
        timeout.tv_sec = now.tv_sec + (msec / 1000);

        unsigned long usec = (msec % 1000) * 1000 + now.tv_usec;
        timeout.tv_sec += ( usec / 1000000 );  // carry over
        usec = usec % 1000000;

        timeout.tv_nsec = usec * 1000;  // micro-sec * 1000 = nano-sec

        int retcode = pthread_cond_timedwait(&fNotified, &fLock, &timeout);
        if (retcode == ETIMEDOUT) {
            result = false;
        } else if ( retcode < 0) {
            pthread_mutex_unlock(&fLock);
            assert(false);
            return false;
        }
    }

    while (getState() == eLocked) {
        pthread_cond_wait(&fReleased, &fLock);
    }

    restoreThreadLockedInfo();

    if (pthread_mutex_unlock(&fLock) != 0) {
        assert(false);
        return false;
    }

    return result;
}

void CSynchronizer2::notifyAll()
{
    if (pthread_mutex_lock(&fLock) != 0) {
        assert(false);
        return;
    }

    if (! isLockedBySelf()) {
        pthread_mutex_unlock(&fLock);
        assert(false);
        return;
    }

    if ((pthread_cond_broadcast(&fNotified)) != 0) {
        assert(false);
    }

    if (pthread_mutex_unlock(&fLock) != 0) {
        assert(false);
        return;
    }
}

